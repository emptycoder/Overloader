# Create formatter for overloader
`TSpecify` attribute allows user apply formatter(s) on class/struct/interface.
Formatter is an attribute which explain overloader generator how to work with specific type.

## Signature
Formatter attribute has next signature:
- `string identifier` # unique identifier
- `Type type`/`Type[] types` # types for which formatter will be applied
- `object[] genericParams` # uses for generic types to specify type templates
- `object[] @params` # maps members to new types
- `params object[] transitions` # for parameter decompositions or parameter type replacements

There are several options for replacing parameter types:
- `"T"` - template param;
- `typeof(double)` - constant type;
- `new[]
{
	typeof(float), typeof(double),
	typeof(double), typeof(long)
}` - switch expression which replaces key type (i) to value type (i + 1);

## Transitions
There are two different transition types:
### Cast transition
- `Type type`
- `string integrityCastCodeTemplate`

`integrityCastCodeTemplate` describe how to cast A type (`Vector3<T>`) to B type (`Vector2<T>`).

### Decomposition transition
- `Type type`
- `object[] paramsMap`

Decompose one parameter `Vector3<T>` on `Vector2<T>` and `T`.

Transitions generate by next scheme:
```
0 0 0 0 0
^

1 0 0 0 0
^
Repeat until it < maxLength[index]
And when first value equals maxLength[index] reset to zero and add 1 to next rank
0 1 0 0 0
^

1 1 0 0 0
^
And so on...
```

Also, formatters support deep substitutions. For example: type `Span<Vector3<double>>` can be overloaded to `Span<Vector2<float>>`.
Small hint: `RemoveBody` allows you remove default body for interfaces.

## Example
```csharp
[assembly: Formatter(typeof(Vector3<>),
	new object[] {"T"},
	new object[]
	{
		"X", "T",
		"Y", "T",
		"Z", "T"
	},
	// Cast transition
	new object[]
	{
		typeof(Vector2<>),
		"new TestProject.Vector3<${T}>() { X = ${Var}.X, Y = ${Var}.Y }"
	},
	// Decomposition transition
	new object[]
	{
		typeof(Vector2<>),
		new object[]
		{
			"X", "X",
			"Y", "Y"
		}
	})]
```
