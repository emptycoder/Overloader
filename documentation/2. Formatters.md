# Create formatter for overloader

Formatters using to describe how to works with specific type for overloader.
To apply formatter for some class/struct/interface use `TSpecify` attribute.

Formatters can easely works with deep substitutions: `Span<Vector3<double>>` (will be overloaded to `Span<Vector2<float>>` according to example).
For interface you can use `RemoveBody` attribute to remove pregenerated default body in interface.

## Signature
Formatter attribute has next signature:
- `string identifier`
- `Type type`/`Type[] types`
- `object[] genericParams`
- `object[] @params`
- `params object[] transitions`

The first argument is unique identifier for Formatter.
Type/Types for which formatter will be applied.<br>
GenericParams using for generic types to specify templates.<br>
Params parameter maps members to new types.<br>
Transitions helps you to create own decomposition of params or parameter type replacement.<br>

There are several possibilities to replace parameter types:
- `"T"` - template param will be replaced on type provided by overloader;
- `typeof(double)` - constant type that will be always applied to member/genericParam;
- `new[]
{
    typeof(float), typeof(double),
    typeof(double), typeof(long)
}` - switch parameter that replace key type (i) to value type (i + 1);

## Transitions
There are two different transition types:
### Integrity transition
- `Type type`
- `string integrityCastCodeTemplate`

To create more overloads that can be casted to main integrity method signature.
In example bellow will be generated alternative methods that replace `Vector3<>` on `Vector2<>` that casts to `Vector3<>` using `integrityCastCodeTemplate`.

### Deconstruct transition
- `Type type`
- `object[] paramsMap`

To create more overloads that can be deconstruct to main deconstruction method  signature.
Let's pretend that template in example will be `double`. Then overloads that replaces `Vector3<double>` on `Vector2<double>` and `double` will be generated.

Transitions will be process by next scheme:
```
0 0 0 0 0
^

1 0 0 0 0
^
Repeat until it < maxLength[index]
And when first value equals maxLength[index] reset to zero and add 1 to next rank
0 1 0 0 0
^
				
1 1 0 0 0
^
And so on...
```

So, all substitution variations will be written.

## Example
```csharp
[assembly: Formatter(typeof(Vector3<>),
	new object[] {"T"},
	new object[]
	{
		"X", "T",
		"Y", "T",
		"Z", "T"
	},
	new object[]
	{
		typeof(Vector2<>),
		"new TestProject.Vector3<${T}>() { X = ${Var}.X, Y = ${Var}.Y }"
	},
	new object[]
	{
		typeof(Vector2<>),
		new object[]
		{
			"X", "X",
			"Y", "Y"
		}
	})]
```
