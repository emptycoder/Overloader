using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Overloader.Chains;
using Overloader.Entities;
using Overloader.Entities.DTOs;
using Overloader.Enums;
using Overloader.Exceptions;
using Overloader.Utils;

namespace Overloader;

[Generator(LanguageNames.CSharp)]
public sealed partial class OverloadsGenerator : IIncrementalGenerator
{
	private const string GeneratedCodeHeader =
		$"""
		 // <auto-generated/>
		 /* This source was auto-generated by {nameof(Overloader)} */

		 #nullable enable
		 #pragma warning disable CS0162 // Unreachable code
		 #pragma warning disable CS0164 // Unreferenced label
		 #pragma warning disable CS0219 // Variable assigned but never used


		 """;

	private static readonly Action<object> OverloadCreation = obj =>
	{
		using var gsb = (GeneratorProperties) obj;
		try
		{
			gsb.Builder.AppendAsConstant(GeneratedCodeHeader);
			if (ChainDeclarations.Main.Execute(gsb) != ChainAction.Break)
				gsb.ReleaseAsOutput();
		}
		catch (LocationException ex)
		{
			gsb.Context.ReportDiagnostic(Diagnostic.Create(
				new DiagnosticDescriptor(
					$"{nameof(Overloader)[0]}E0001",
					$"An {nameof(DiagnosticSeverity.Error)} was thrown by {nameof(Overloader)} during Execution",
					ex.InnerException!.ToString(),
					nameof(Overloader),
					DiagnosticSeverity.Error,
					true),
				ex.Location));
		}
		catch (Exception ex)
		{
			gsb.Context.ReportDiagnostic(Diagnostic.Create(
				new DiagnosticDescriptor(
					$"{nameof(Overloader)[0]}E0002",
					$"An {nameof(DiagnosticSeverity.Error)} was thrown by {nameof(Overloader)} during Execution",
					ex.ToString(),
					nameof(Overloader),
					DiagnosticSeverity.Error,
					true),
				Location.None));
		}
	};

	public static void Execute(
		SourceProductionContext context,
		Compilation compilation,
		ImmutableArray<CandidateDto?> candidates,
		ImmutableArray<AttributeSyntax> globalAttributes)
	{
		try
		{
#if !DEBUG || ForceTasks
			var tasks = new List<Task>();
#endif
			var formatters = globalAttributes.GetFormatters(compilation);
			var formattersBundles = globalAttributes.GetBundles(compilation);

			foreach (var candidate in candidates.Select(candidate => candidate!.Value))
			{
				string candidateClassName = candidate.Syntax.Identifier.ValueText;
				var formattersSample = formatters.GetFormattersSample(formattersBundles, candidate.FormattersToUse, candidate.Syntax);

				var formatterOverloadProps = new GeneratorProperties(
					context,
					compilation,
					candidate,
					formattersSample,
					true,
					candidateClassName,
					candidate.DefaultType!.GetType(compilation),
					null);
#if !DEBUG || ForceTasks
				tasks.Add(Task.Factory.StartNew(OverloadCreation, formatterOverloadProps));
#else
				OverloadCreation(formatterOverloadProps);
#endif

				foreach (var overloadDto in candidate.OverloadTypes)
				{
					var genericWithFormatterOverloadProps = new GeneratorProperties(
						context,
						compilation,
						candidate,
						formattersSample,
						false,
						overloadDto.ClassName,
						overloadDto.TypeSyntax.GetType(compilation),
						formatters.GetFormattersSample(formattersBundles, overloadDto.FormattersToUse, overloadDto.TypeSyntax)
					);

#if !DEBUG || ForceTasks
					tasks.Add(Task.Factory.StartNew(OverloadCreation, genericWithFormatterOverloadProps));
#else
					OverloadCreation(genericWithFormatterOverloadProps);
#endif
				}
			}

#if !DEBUG || ForceTasks
			tasks.ForEach(task => task.Wait());
#endif
		}
		catch (Exception ex)
		{
			ReportErrorDuringInitialize(context, ex);
		}
	}
}
