using Microsoft.CodeAnalysis.CSharp;

namespace Overloader.ContentBuilders;

public abstract class SourceBuilder : IDisposable
{
	private const string PaddingStr = "\t";

	private uint _nestedLevel;
	private bool _nextLine = true;

	public SourceBuilder Append(SourceBuilder builder)
	{
		if (_nextLine)
		{
			for (int index = 0; index < _nestedLevel; index++)
				AppendString(PaddingStr);
			_nextLine = false;
		}
		
		for (int index = 0; index < builder.Length; index++)
			AppendChar(builder[index]);
		
		return this;
	}

	public SourceBuilder AppendChainMemberNameComment(string callerMemberName) =>
		AppendAsConstant($"// Generated by: {callerMemberName}", 1);
	
	public SourceBuilder Append(string str, byte breakCount = 0) =>
		AppendWoTrim(str.AsSpan().Trim(), breakCount);
	
	public SourceBuilder Append(ReadOnlySpan<char> str, byte breakCount = 0) =>
		AppendWoTrim(str.Trim(), breakCount);

	public SourceBuilder AppendAndClear(SourceBuilder builder)
	{
		Append(builder);
		builder.Clear();
		return this;
	}

	public SourceBuilder AppendAsConstant(string str, byte breakCount = 0)
	{
		if (_nextLine)
		{
			for (int index = 0; index < _nestedLevel; index++)
				AppendString(PaddingStr);
			_nextLine = false;
		}

		AppendString(str);

		if (breakCount <= 0) return this;

		for (int index = 0; index < breakCount; index++)
			AppendChar('\n');
		_nextLine = true;

		return this;
	}

	public SourceBuilder AppendWoTrim(string str, byte breakCount = 0) =>
		AppendWoTrim(str.AsSpan(), breakCount);

	public SourceBuilder AppendWoTrim(ReadOnlySpan<char> str, byte breakCount = 0)
	{
		if (_nextLine)
		{
			for (int index = 0; index < _nestedLevel; index++)
				AppendString(PaddingStr);
			_nextLine = false;
		}

		for (int index = 0; index < str.Length; index++)
		{
			char character = str[index];
			switch (character)
			{
				case '\r':
				case '\t':
					continue;
				case '\n':
					AppendChar('\n');
					_nextLine = true;
					return index + 1 < str.Length
						? Append(str.Slice(index + 1), breakCount)
						: this;
				default:
					AppendChar(character);
					break;
			}
		}

		if (breakCount <= 0) return this;

		for (int index = 0; index < breakCount; index++)
			AppendChar('\n');
		_nextLine = true;

		return this;
	}

	public SourceBuilder NestedIncrease(SyntaxKind? withSyntax = null)
	{
		if (withSyntax.HasValue)
			Append(SyntaxFacts.GetText(withSyntax.Value), 1);
		_nestedLevel++;

		return this;
	}

	public SourceBuilder NestedDecrease(SyntaxKind? withSyntax = null)
	{
		if (_nestedLevel == 0)
			throw new Exception("Minimum nested level has been reached");

		_nestedLevel--;
		if (withSyntax.HasValue)
			Append(SyntaxFacts.GetText(withSyntax.Value), 1);

		return this;
	}

	public SourceBuilder WhiteSpace()
	{
		AppendChar(' ');
		return this;
	}

	public SourceBuilder BreakLine()
	{
		_nextLine = true;
		AppendChar('\n');
		return this;
	}

	public void Clear()
	{
		_nextLine = true;
		_nestedLevel = 0;
		ClearBuilder();
	}

	public virtual void Dispose()
	{
		Clear();
		DisposeBuilder();
	}

	public SourceBuilder GetDependentInstance()
	{
		var instance = NewBuilder();
		instance._nestedLevel = _nestedLevel;

		return instance;
	}

	protected abstract char this[int index] { get; }
	protected abstract int Length { get; }
	protected abstract void AppendChar(char character);
	protected abstract void AppendString(string str);
	protected abstract void DisposeBuilder();
	protected abstract void ClearBuilder();
	protected abstract SourceBuilder NewBuilder();
	public abstract SourceBuilder CloneBuilder();
}
