using Microsoft.CodeAnalysis.CSharp;
using Overloader.Exceptions;

namespace Overloader.ContentBuilders;

public abstract class SourceBuilder : IDisposable
{
	private const string PaddingStr = "\t";

	private uint _nestedLevel;
	private bool _nextLine;

	protected abstract char this[int index] { get; }
	protected abstract int Length { get; }

	public virtual void Dispose()
	{
		Clear();
		DisposeBuilder();
	}

	public SourceBuilder Append(SourceBuilder builder)
	{
		if (_nextLine)
		{
			for (int index = 0; index < _nestedLevel; index++)
				AppendStringToBuilder(PaddingStr);
			_nextLine = false;
		}

		for (int index = 0; index < builder.Length; index++)
			AppendCharToBuilder(builder[index]);

		return this;
	}

	public SourceBuilder AppendChainMemberNameComment(string callerMemberName) =>
		AppendAsConstant($"// Generated by: {callerMemberName}", 1);

	public SourceBuilder AppendAsDependent(SourceBuilder builder)
	{
		_nextLine = false;
		for (int index = 0; index < builder.Length; index++)
			AppendCharToBuilder(builder[index]);

		return this;
	}

	public SourceBuilder AppendAndClear(SourceBuilder builder)
	{
		Append(builder);
		builder.Clear();
		return this;
	}

	public SourceBuilder AppendAsConstant(string str, byte breakCount = 0)
	{
		if (_nextLine)
		{
			for (int index = 0; index < _nestedLevel; index++)
				AppendStringToBuilder(PaddingStr);
			_nextLine = false;
		}

		AppendStringToBuilder(str);

		if (breakCount <= 0) return this;

		for (int index = 0; index < breakCount; index++)
			AppendCharToBuilder('\n');
		_nextLine = true;

		return this;
	}

	public SourceBuilder Append(string str, byte breakCount = 0) =>
		Append(str.AsSpan(), breakCount);

	public SourceBuilder Append(ReadOnlySpan<char> str, byte breakCount = 0)
	{
		if (_nextLine)
		{
			for (int index = 0; index < _nestedLevel; index++)
				AppendStringToBuilder(PaddingStr);
			_nextLine = false;
		}

		for (int index = 0; index < str.Length; index++)
		{
			char character = str[index];
			switch (character)
			{
				case '\r':
				case '\t':
					break;
				case '\n':
					AppendCharToBuilder('\n');
					_nextLine = true;
					return index + 1 < str.Length
						? TrimAppend(str.Slice(index + 1), breakCount)
						: this;
				default:
					AppendCharToBuilder(character);
					break;
			}
		}

		if (breakCount <= 0) return this;

		for (int index = 0; index < breakCount; index++)
			AppendCharToBuilder('\n');
		_nextLine = true;

		return this;
	}

	public SourceBuilder NestedIncrease(SyntaxKind? withSyntax = null)
	{
		if (withSyntax.HasValue)
			Append(SyntaxFacts.GetText(withSyntax.Value));
		_nestedLevel++;

		return this;
	}

	public SourceBuilder NestedDecrease(SyntaxKind? withSyntax = null)
	{
		if (_nestedLevel == 0)
			throw new Exception("Minimum nested level has been reached")
				.NotExpected();

		_nestedLevel--;
		if (withSyntax.HasValue)
			Append(SyntaxFacts.GetText(withSyntax.Value));

		return this;
	}

	public SourceBuilder WhiteSpace()
	{
		AppendCharToBuilder(' ');
		return this;
	}

	public SourceBuilder BreakLine()
	{
		_nextLine = true;
		AppendCharToBuilder('\n');
		return this;
	}

	public void Clear()
	{
		_nextLine = false;
		_nestedLevel = 0;
		ClearBuilder();
	}

	public SourceBuilder GetDependentInstance()
	{
		var instance = NewBuilder();
		instance._nestedLevel = _nestedLevel;

		return instance;
	}

	protected abstract void AppendCharToBuilder(char character);
	protected abstract void AppendStringToBuilder(string str);
	protected abstract void DisposeBuilder();
	protected abstract void ClearBuilder();
	protected abstract SourceBuilder NewBuilder();
	public abstract SourceBuilder CloneBuilder();

	#region TrimAppend

	public SourceBuilder TrimAppend(string str, byte breakCount = 0) =>
		Append(str.AsSpan().Trim(), breakCount);

	public SourceBuilder TrimAppend(ReadOnlySpan<char> str, byte breakCount = 0) =>
		Append(str.Trim(), breakCount);

	public SourceBuilder TrimAppend(string str, ReadOnlySpan<char> trimChars, byte breakCount = 0) =>
		Append(str.AsSpan().Trim(trimChars), breakCount);

	public SourceBuilder TrimAppend(ReadOnlySpan<char> str, ReadOnlySpan<char> trimChars, byte breakCount = 0) =>
		Append(str.Trim(trimChars), breakCount);

	#endregion

	#region TrimEnd

	public SourceBuilder TrimEndAppend(string str, byte breakCount = 0) =>
		Append(str.AsSpan().TrimEnd(), breakCount);

	public SourceBuilder TrimEndAppend(ReadOnlySpan<char> str, byte breakCount = 0) =>
		Append(str.TrimEnd(), breakCount);

	public SourceBuilder TrimEndAppend(string str, ReadOnlySpan<char> trimChars, byte breakCount = 0) =>
		Append(str.AsSpan().TrimEnd(trimChars), breakCount);

	public SourceBuilder TrimEndAppend(ReadOnlySpan<char> str, ReadOnlySpan<char> trimChars, byte breakCount = 0) =>
		Append(str.TrimEnd(trimChars), breakCount);

	#endregion

	#region TrimStart

	public SourceBuilder TrimStartAppend(string str, byte breakCount = 0) =>
		Append(str.AsSpan().TrimStart(), breakCount);

	public SourceBuilder TrimStartAppend(ReadOnlySpan<char> str, byte breakCount = 0) =>
		Append(str.TrimStart(), breakCount);

	public SourceBuilder TrimStartAppend(string str, ReadOnlySpan<char> trimChars, byte breakCount = 0) =>
		Append(str.AsSpan().TrimStart(trimChars), breakCount);

	public SourceBuilder TrimStartAppend(ReadOnlySpan<char> str, ReadOnlySpan<char> trimChars, byte breakCount = 0) =>
		Append(str.TrimStart(trimChars), breakCount);

	#endregion
}
